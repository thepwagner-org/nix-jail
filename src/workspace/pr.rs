//! Pull request creation using GitHub API
//!
//! This module provides functions to create pull requests on GitHub
//! using direct HTTP requests.

use super::WorkspaceError;
use serde::{Deserialize, Serialize};

/// Parse a GitHub URL into (owner, repo) components
///
/// Supports both HTTPS and SSH formats:
/// - https://github.com/owner/repo
/// - git@github.com:owner/repo
/// - https://github.com/owner/repo.git
fn parse_github_url(url: &str) -> Result<(String, String), WorkspaceError> {
    // Remove .git suffix if present
    let url = url.trim_end_matches(".git");

    // Try HTTPS format first
    if let Some(rest) = url.strip_prefix("https://github.com/") {
        let parts: Vec<&str> = rest.split('/').collect();
        if parts.len() >= 2 {
            return Ok((parts[0].to_string(), parts[1].to_string()));
        }
    }

    // Try SSH format
    if let Some(rest) = url.strip_prefix("git@github.com:") {
        let parts: Vec<&str> = rest.split('/').collect();
        if parts.len() >= 2 {
            return Ok((parts[0].to_string(), parts[1].to_string()));
        }
    }

    Err(WorkspaceError::InvalidPath(format!(
        "Invalid GitHub URL format: {}",
        url
    )))
}

#[derive(Serialize)]
struct CreatePullRequest {
    title: String,
    head: String,
    base: String,
    body: String,
}

#[derive(Deserialize)]
struct PullRequestResponse {
    html_url: String,
}

/// Create a pull request on GitHub
///
/// # Arguments
/// * `repo_url` - GitHub repository URL (HTTPS or SSH format)
/// * `head_branch` - Source branch for the PR (e.g., "job-01HXABC...")
/// * `base_branch` - Target branch for the PR (e.g., "main")
/// * `commits` - List of commit messages to include in PR body
/// * `github_token` - GitHub personal access token
///
/// # Returns
/// The HTML URL of the created pull request
pub async fn create_pull_request(
    repo_url: &str,
    head_branch: &str,
    base_branch: &str,
    commits: &[String],
    github_token: &str,
) -> Result<String, WorkspaceError> {
    // Parse owner/repo from URL
    let (owner, repo) = parse_github_url(repo_url)?;

    tracing::info!(
        owner = %owner,
        repo = %repo,
        head = %head_branch,
        base = %base_branch,
        "creating pull request"
    );

    // Generate title from first commit
    let title = if commits.is_empty() {
        "Auto-PR: Changes from nix-jail".to_string()
    } else {
        format!("Auto-PR: {}", commits[0])
    };

    // Generate body with all commits
    let commit_list = if commits.is_empty() {
        "No commit messages available".to_string()
    } else {
        commits
            .iter()
            .map(|c| format!("- {}", c))
            .collect::<Vec<_>>()
            .join("\n")
    };

    let body = format!(
        "## Commits\n{}\n\n---\nðŸ¤– Generated by [nix-jail](https://github.com/thepwagner/nix-jail)",
        commit_list
    );

    let request_body = CreatePullRequest {
        title,
        head: head_branch.to_string(),
        base: base_branch.to_string(),
        body,
    };

    let client = reqwest::Client::new();
    let response = client
        .post(format!(
            "https://api.github.com/repos/{}/{}/pulls",
            owner, repo
        ))
        .header("Authorization", format!("Bearer {}", github_token))
        .header("Accept", "application/vnd.github+json")
        .header("User-Agent", "nix-jail")
        .header("X-GitHub-Api-Version", "2022-11-28")
        .json(&request_body)
        .send()
        .await
        .map_err(|e| {
            WorkspaceError::IoError(std::io::Error::other(format!(
                "Failed to send pull request: {}",
                e
            )))
        })?;

    if !response.status().is_success() {
        let status = response.status();
        let body = response.text().await.unwrap_or_default();
        return Err(WorkspaceError::IoError(std::io::Error::other(format!(
            "GitHub API error {}: {}",
            status, body
        ))));
    }

    let pr: PullRequestResponse = response.json().await.map_err(|e| {
        WorkspaceError::IoError(std::io::Error::other(format!(
            "Failed to parse pull request response: {}",
            e
        )))
    })?;

    tracing::info!(pr_url = %pr.html_url, "Pull request created successfully");
    Ok(pr.html_url)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_github_url_https() {
        let (owner, repo) = parse_github_url("https://github.com/thepwagner/nix-jail")
            .expect("failed to parse https url");
        assert_eq!(owner, "thepwagner");
        assert_eq!(repo, "nix-jail");
    }

    #[test]
    fn test_parse_github_url_https_with_git() {
        let (owner, repo) = parse_github_url("https://github.com/thepwagner/nix-jail.git")
            .expect("failed to parse https url with .git");
        assert_eq!(owner, "thepwagner");
        assert_eq!(repo, "nix-jail");
    }

    #[test]
    fn test_parse_github_url_ssh() {
        let (owner, repo) = parse_github_url("git@github.com:thepwagner/nix-jail")
            .expect("failed to parse ssh url");
        assert_eq!(owner, "thepwagner");
        assert_eq!(repo, "nix-jail");
    }

    #[test]
    fn test_parse_github_url_ssh_with_git() {
        let (owner, repo) = parse_github_url("git@github.com:thepwagner/nix-jail.git")
            .expect("failed to parse ssh url with .git");
        assert_eq!(owner, "thepwagner");
        assert_eq!(repo, "nix-jail");
    }

    #[test]
    fn test_parse_github_url_invalid() {
        let result = parse_github_url("https://gitlab.com/user/repo");
        assert!(result.is_err());
    }
}
